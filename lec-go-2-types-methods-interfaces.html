<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Part 2: Methods and Interfaces</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Part 2: Methods and Interfaces</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="overview" class="slide section level1">
<h1>Overview</h1>
<ul>
<li>Simple versus full type inference</li>
<li>Methods</li>
<li>Interfaces</li>
</ul>
</div>
<div id="recall-simple-form-of-type-inference" class="slide section level1">
<h1>Recall: Simple form of type inference</h1>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> main() {
    <span class="kw">var</span> x <span class="dt">int</span>
    x = <span class="dv">1</span>
    y := x + <span class="dv">1</span>
    fmt.Printf(<span class="st">&quot;y = %d&quot;</span>, y)

}</code></pre></div>
<p>The type of <code>y</code> is inferred by the right-hand side.</p>
<p>Pretty convenient!</p>
<p>Languages like Haskell support <em>full</em> type inference where the types of functions can be inferred.</p>
<h2 id="simple-versus-full-type-inference">Simple versus full type inference</h2>
<p><em>Type inference</em> refers to the process of automatically inferring the type of program text (variables, expressions, functions, ...).</p>
<p><em>Type checking</em> refers to the process of automatically checking if the provided (user-annotated) type information matches the progrm text.</p>
<p>Both methods can either be carried out statically (at compile-time) or dynamically (at run-time).</p>
<p>Both methods rely on <em>typing rules</em> that specify the conditions under which some program text is type correct. For example, for an assignment statement we demand that the types of the expressions of the left-hand and right-hand side must be identical. There is an entire branch of computer science devoted in the formalization of such typing rules and how to effectively implement via type checking/inference.</p>
<p>Here are some sample typing rules describing the well-typing of arithmetic expressions.</p>
<pre><code>G denotes a set of type/variable declarations of the form
{x1 : int, ..., xn : int}

      x : int is an element in G
(Var) -------------
      G |- x : int

       i is a natural number
(Int) ---------------
      G |- i : int

      G |- e1 : int     G |- e2 : int
(Add) ---------------------------------
      G |- e1 + e2 : int</code></pre>
<p>Above to be read as &quot;if-then&quot; rules. The part above the <code>---</code> is the precondition (premise) and the part below is the postcondition (conclusion).</p>
<p>We refer to <code>G |- e : int</code> as a judgment stating that in type environment <code>G</code>, the expression <code>e</code> has type <code>int</code>.</p>
<p>We take a brief look at type checking/inference in Go. Consider the following example.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> f(x <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">var</span> y <span class="dt">int</span>
    y = x + <span class="dv">1</span>
    <span class="kw">return</span> y
}

<span class="kw">func</span> f2(x <span class="dt">int</span>) <span class="dt">int</span> {
    y := x + <span class="dv">1</span>
    <span class="kw">return</span> y
}

<span class="kw">func</span> main() {
    <span class="kw">var</span> x <span class="dt">int</span>
    x = <span class="dv">1</span>

    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, f(x))
    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, f2(x))
    g := f
    y := <span class="dv">1</span>
    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, g(y))

}</code></pre></div>
<p>Via <code>x := e</code> we indicate that on the left-hand side we introduce (declare) a fresh variable <code>x</code> whose value is determined by the right-hand side <code>e</code>. No explicit type annotations are provided as the type of <code>x</code> can be determined by inferring the type of <code>e</code>.</p>
<p>How does this (simple) form of type inference work? We can assume that the types of all variables on the right-hand side is known. So, we check by following the typing rules of the right-hand side expression is type correct. As part of this type checking process, we also infer the expression's type.</p>
<p>For example, consider the expression from above.</p>
<pre><code>x + 1

where x is of type int


We type check x + 1 as follows.

   We observe the structure of the expression.
   In our case, we find addition with x and 1 as operands.
   So rule (Add) from above applies.

   We can conclude that x + 1 is of type int if
   x is of type int and 1 is of type int.
   This holds!

   Notice something?
   By the way, we infer the type of x + 1!
   We traverse the structure of the expression (structural induction)
   by going from the outer level (addition) to the inner level (operands).
</code></pre>
<p>What is <em>full</em> type inference? If we could omit <em>all</em> type annotations. In Go we still need to provide of function definitions. In other languages, e.g. Haskell, the type of function definitions is optional. We say that such languages support full type inference.</p>
<p>Let's consider our running example where all type annotations are omitted.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> f3(x) {
   y = x + <span class="dv">1</span>
   <span class="kw">return</span> y
}</code></pre></div>
<p>Let's attempt to reconstruct the missing type annotations by inspection of the program text.</p>
<pre><code>1. Consider x + 1
   Based on the above typing rules we deduce that
   x + 1 is of type int and therefore
   x is of type int as well.

2. Consider y = x + 1
   The types of left-hand and right-hand side must match.
   Hence, we deduce that y is of type int.

3. return y
   implies that f3&#39;s return type is int</code></pre>
<p>Putting the pieces together, we deduce the following.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> func3(x <span class="dt">int</span>) <span class="dt">int</span> {
   <span class="kw">var</span> y <span class="dt">int</span>
   y = x + <span class="dv">1</span>
   <span class="kw">return</span> y
}</code></pre></div>
<p>Is that the only type we can give to this program text. Well, Go also supports float32. So, another possible annotation would be the following.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> func3(x <span class="dt">float32</span>) <span class="dt">float32</span> {
   <span class="kw">var</span> y <span class="dt">float32</span>
   y = x + <span class="dv">1</span>
   <span class="kw">return</span> y
}</code></pre></div>
<p>The program text <code>x + 1</code> typechecks under the assumption that the integer constant <code>1</code> can be coerced into a floating point number.</p>
<p>The above, several types that can be inferred, highlights one of the challenges of type inference. The quest is to design a programming language that enjoys <em>principal</em> type inference. By principal we mean, type inference yields a most general type that subsumes all other types. For more details on this subject, please refer to the <a href="https://en.wikipedia.org/wiki/Principal_type">research literature</a>.</p>
</div>
<div id="methods-on-named-types" class="slide section level1">
<h1>Methods on named types</h1>
<p>We can define methods on named types where we can use the &quot;dot&quot; notation to call methods.</p>
<h2 id="method-definitions">Method definitions</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> rectangle <span class="kw">struct</span> {
    length <span class="dt">int</span>
    width  <span class="dt">int</span>
}

<span class="kw">func</span> (r rectangle) area() <span class="dt">int</span> {
    <span class="kw">return</span> r.length * r.width
}</code></pre></div>
<p>The named type argument preceeds all other arguments (in this example, area has no further arguments). There is no <code>self</code> or <code>this</code>. Struct values are always referenced by name.</p>
<h2 id="method-calls">Method calls</h2>
<p>We call methods by using the &quot;dot&quot; notation.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">r1.area()</code></pre></div>
<p>In the above definition of method <code>area</code> on named type <code>rectangle</code>, the argument <code>r</code> is passed to <code>area</code> as a value. We must use call-by reference if we wish to update <code>r</code>'s field values.</p>
<h2 id="methods-and-call-by-reference">Methods and call-by reference</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (r *rectangle) scale(s <span class="dt">int</span>) {
    r.length = r.length * s
    r.width = r.width * s
}</code></pre></div>
<p>The <code>*</code> indicates that we pass <code>r</code> to <code>scale</code> by reference. Thus, the update is globally visible.</p>
<p>In Go, the compiler inserts the <code>&amp;</code> operator to build a reference to r.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">r1.scale(<span class="dv">3</span>)
(&amp;r1).scale(<span class="dv">3</span>)</code></pre></div>
<p>The above statements are equivalent. Go will automatically perform the conversion.</p>
<h2 id="complete-example">Complete example</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">type</span> rectangle <span class="kw">struct</span> {
    length <span class="dt">int</span>
    width  <span class="dt">int</span>
}

<span class="kw">func</span> (r rectangle) area() <span class="dt">int</span> {
    <span class="kw">return</span> r.length * r.width
}

<span class="kw">func</span> (r *rectangle) scale(s <span class="dt">int</span>) {
    r.length = r.length * s
    r.width = r.width * s
}

<span class="kw">func</span> main() {
    <span class="kw">var</span> r1 rectangle = rectangle{<span class="dv">1</span>, <span class="dv">2</span>}
    <span class="kw">var</span> r2 rectangle = rectangle{width: <span class="dv">2</span>, length: <span class="dv">1</span>}
    r3 := rectangle{width: <span class="dv">2</span>, length: <span class="dv">1</span>}
    r3.scale(<span class="dv">3</span>)

    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, r1.area()+r2.area()+r3.area())

}</code></pre></div>
</div>
<div id="structs---further-stuff" class="slide section level1">
<h1>Structs - Further stuff</h1>
<ul>
<li><p>Encapsulation and visibility</p></li>
<li><p>Mimicing inheritance via annonymous fields</p></li>
<li><p>...</p></li>
</ul>
</div>
<div id="method-overloading-interfaces" class="slide section level1">
<h1>Method overloading + Interfaces</h1>
<h2 id="highlights">Highlights</h2>
<p><b>Overloading</b>. Define a function, method, operator with the same name in the same scope.</p>
<p>Go supports <em>method overloading</em> where <em>method dispatch</em> is based on the &quot;receiver&quot; type. Consider the example</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Int <span class="kw">struct</span> { val <span class="dt">int</span> }

<span class="kw">func</span> (i Int) plus(x <span class="dt">int</span>) <span class="dt">int</span> {
   <span class="kw">return</span> i.val + x
}

<span class="kw">type</span> MyFloat32 <span class="dt">float32</span>

<span class="kw">func</span> (f MyFloat32) plus(x <span class="dt">float32</span>) <span class="dt">float32</span> {
    <span class="kw">return</span> (<span class="dt">float32</span>(f)) + x
}</code></pre></div>
<ul>
<li><p>The name <code>plus</code> is overloaded because there exist two definitions for <code>plus</code>.</p></li>
<li><p>(Overloaded) methods takes as argument a receiver type which is the argument preceeding the method name.</p></li>
<li><p>These receivers must be user-defined types (introduced via the <code>type</code> keyword).</p></li>
<li><p>The type <code>MyFloat32</code> is a new type but is ismorphic to the built-in type <code>float32</code>.</p></li>
<li><p>The choice which method is called (method dispatch) depends on the receiver type.</p></li>
<li><p>The calling convention for methods in Go resembles the common &quot;dot&quot; notation used in OO language. For example, consider</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    i := Int {<span class="dv">1</span>}
    r1 := i.plus(<span class="dv">1</span>)

    f := MyFloat32 (<span class="dv">1</span><span class="fl">.0</span>)
    r2 := f.plus(<span class="dv">1</span><span class="fl">.0</span>)       </code></pre></div>
<p>Here is another example.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> rectangle <span class="kw">struct</span> {
    length <span class="dt">int</span>
    width  <span class="dt">int</span>
}

<span class="kw">type</span> square <span class="kw">struct</span> {
    length <span class="dt">int</span>
}


<span class="kw">func</span> (r rectangle) area() <span class="dt">int</span> {
    <span class="kw">return</span> r.length * r.width
}

<span class="kw">func</span> (r square) area() <span class="dt">int</span> {
    <span class="kw">return</span> r.length * r.length
}</code></pre></div>
<p>At run-time, the choice which definition of <code>area</code> to select is based on the receiver type (leading argument of the method definition).</p>
<p><b>Interfaces</b> are contracts between expected behavior and actual implementation.</p>
<p>In Go, we can build a common interface for overloaded methods. Consider</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> ADDInt <span class="kw">interface</span> {
    addInt(<span class="dt">int</span>) <span class="dt">float32</span>
}</code></pre></div>
<p>Interfaces can appear as arguments and return values.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> useAdd(a ADDInt, x <span class="dt">int</span>) <span class="dt">float32</span> {
    <span class="kw">return</span> a.addInt(x)
}</code></pre></div>
<p>Actual implementations are provided as overloaded methods</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (i Int) addInt(x <span class="dt">int</span>) <span class="dt">float32</span> {
    <span class="kw">return</span> <span class="dt">float32</span> (i.val + x)
}

<span class="kw">func</span> (f MyFloat32) addInt(x <span class="dt">int</span>) <span class="dt">float32</span> {
    <span class="kw">return</span> (<span class="dt">float32</span>(f)) + <span class="dt">float32</span> (x)
}</code></pre></div>
<p>and the concrete instances are selected based on the arguments provided for interfaces.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    a1 := useAdd(Int{<span class="dv">2</span>},<span class="dv">2</span>)

    a2 := useAdd(MyFloat32 (<span class="dv">2</span><span class="fl">.0</span>),<span class="dv">2</span>)</code></pre></div>
<p>In Go, interfaces can be nested and actual implementations added at any time.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> MULTInt <span class="kw">interface</span> {
    multInt(<span class="dt">int</span>) <span class="dt">float32</span>
        ADDInt
}

<span class="kw">func</span> useAddMult(a MULTInt, x <span class="dt">int</span>) <span class="dt">float32</span> {
    <span class="kw">return</span> a.addInt(x) + a.multInt(x)
}</code></pre></div>
<p>The Go type system guarantees that actual implementations are available.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (i Int) multInt(x <span class="dt">int</span>) <span class="dt">float32</span> {
    <span class="kw">return</span> <span class="dt">float32</span> (i.val * x)
}


m1 := useAddMult(Int{<span class="dv">2</span>},<span class="dv">2</span>)        <span class="co">// type checks</span>

m2 := useAddMult(Float32 (<span class="dv">2</span><span class="fl">.0</span>),<span class="dv">2</span>) <span class="co">// yields type error!</span></code></pre></div>
<p>We encounter a type error because the MultInt instance on type <code>Float32</code> can not be satisfied (because there is no such definition for <code>multInt</code>).</p>
<h2 id="short-summary">Short summary</h2>
<ul>
<li><p>Method names in an interface hierarchy must be distinct.</p></li>
<li><p>Interface hierarchies must be acyclic.</p></li>
<li><p>Method names can appear in distinct interfaces.</p></li>
<li><p>Via interfaces + method overloading, Go supports a (limited) form of &quot;ad-hoc polymorphism&quot;.</p></li>
</ul>
<h2 id="any-interface">&quot;Any&quot; Interface</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">interface</span>{}</code></pre></div>
<pre><code>Any interface. Similar to the type `Object` in Java.

We can perform some run-time type cast.</code></pre>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">func</span> any(anything <span class="kw">interface</span>{}) {
    <span class="kw">switch</span> v := anything.(<span class="kw">type</span>) {
    <span class="kw">case</span> <span class="dt">int</span>:
    fmt.Printf(<span class="st">&quot;some int %d </span><span class="ch">\n</span><span class="st">&quot;</span>, v)
    <span class="kw">case</span> rectangle:
    fmt.Println(v)
    r := anything.(rectangle)
    fmt.Printf(<span class="st">&quot;length = %d, width = %d </span><span class="ch">\n</span><span class="st">&quot;</span>, r.length, r.width)
    <span class="kw">default</span>:
    fmt.Println(<span class="st">&quot;don&#39;t know&quot;</span>)
    }

    }</code></pre></div>
<pre><code>* We can also cast to a specific type, see `anything.(rectangle)`

* Such a cast may fail

* We can catch failure via</code></pre>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    r, ok := anything.(rectangle)</code></pre></div>
<pre><code>`ok` equals false in case the cast fails

* BTW, Go automatically performs a `break` after each case.

* Complete example</code></pre>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">package</span> main

    <span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

    <span class="kw">type</span> rectangle <span class="kw">struct</span> {
    length <span class="dt">int</span>
    width  <span class="dt">int</span>
    }

    <span class="kw">func</span> any(anything <span class="kw">interface</span>{}) {
    <span class="kw">switch</span> v := anything.(<span class="kw">type</span>) {
    <span class="kw">case</span> <span class="dt">int</span>:
    fmt.Printf(<span class="st">&quot;some int %d </span><span class="ch">\n</span><span class="st">&quot;</span>, v)
    <span class="kw">case</span> rectangle:
        fmt.Println(v)
        r := anything.(rectangle)
        fmt.Printf(<span class="st">&quot;length = %d, width = %d </span><span class="ch">\n</span><span class="st">&quot;</span>, r.length, r.width)
    <span class="kw">default</span>:
        fmt.Println(<span class="st">&quot;don&#39;t know&quot;</span>)
    }

}

<span class="kw">func</span> main() {
    any(<span class="dv">1</span>)

    any(rectangle{<span class="dv">1</span>, <span class="dv">2</span>})

}</code></pre></div>
<h2 id="further-examples">Further examples</h2>
<h3 id="shapes">Shapes</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> shape <span class="kw">interface</span> {
    area() <span class="dt">int</span>
}</code></pre></div>
<p>Some functions which assume a shape behavior.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> shapeTwo(sh1, sh2 shape) <span class="dt">int</span> {
    <span class="kw">return</span> sh1.area() + sh2.area()
}

<span class="kw">func</span> shapes(shs ...shape) <span class="dt">int</span> {
    <span class="kw">var</span> a <span class="dt">int</span> = <span class="dv">0</span>
    <span class="kw">for</span> _, elem := <span class="kw">range</span> shs {
        a = a + elem.area()
    }
    <span class="kw">return</span> a
    }</code></pre></div>
<p>We can define arguments with a variable number of arguments (of the some type) and iterate over them via a <code>for</code> loop.</p>
<p>In the above we don't care (<code>_</code>) about the index position.</p>
<p>Some concrete instances.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> rectangle <span class="kw">struct</span> {
    length <span class="dt">int</span>
    width  <span class="dt">int</span>
}

<span class="kw">type</span> square <span class="kw">struct</span> {
    length <span class="dt">int</span>
}

<span class="kw">func</span> (r rectangle) area() <span class="dt">int</span> {
    <span class="kw">return</span> r.length * r.width
}

<span class="kw">func</span> (s square) area() <span class="dt">int</span> {
    <span class="kw">return</span> s.length * s.length
}</code></pre></div>
<ul>
<li>Complete example</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">type</span> rectangle <span class="kw">struct</span> {
    length <span class="dt">int</span>
    width  <span class="dt">int</span>
}

<span class="kw">type</span> square <span class="kw">struct</span> {
    length <span class="dt">int</span>
}

<span class="kw">func</span> (r rectangle) area() <span class="dt">int</span> {
    <span class="kw">return</span> r.length * r.width
}

<span class="kw">func</span> (s square) area() <span class="dt">int</span> {
    <span class="kw">return</span> s.length * s.length
}

<span class="kw">type</span> shape <span class="kw">interface</span> {
    area() <span class="dt">int</span>
}

<span class="kw">func</span> shapeTwo(sh1, sh2 shape) <span class="dt">int</span> {
    <span class="kw">return</span> sh1.area() + sh2.area()
}

<span class="kw">func</span> shapes(shs ...shape) <span class="dt">int</span> {
    <span class="kw">var</span> a <span class="dt">int</span> = <span class="dv">0</span>
    <span class="kw">for</span> _, elem := <span class="kw">range</span> shs {
        a = a + elem.area()
    }
    <span class="kw">return</span> a
}

<span class="kw">func</span> main() {
    <span class="kw">var</span> r1 rectangle = rectangle{<span class="dv">1</span>, <span class="dv">2</span>}
    <span class="kw">var</span> s1 square = square{<span class="dv">3</span>}

    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, r1.area()+s1.area())

    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, shapeTwo(r1, s1))

    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, shapes(r1, r1, s1, s1, s1))

}</code></pre></div>
<h3 id="abstract-data-types-via-interfaces">Abstract data types via interfaces</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Set <span class="kw">interface</span> {
    empty() Set
    isEmpty() <span class="dt">bool</span>
    insert(<span class="dt">int</span>) Set 
}

<span class="kw">type</span> SetImpl []<span class="dt">int</span>

<span class="kw">func</span> (xs SetImpl) empty() Set {
       <span class="kw">return</span> (SetImpl)([]<span class="dt">int</span>{})
}

<span class="kw">func</span> (xs SetImpl) isEmpty() <span class="dt">bool</span> {
    <span class="kw">return</span> <span class="fu">len</span>(xs) == <span class="dv">0</span>
}

<span class="kw">func</span> (xs SetImpl) insert(x <span class="dt">int</span>) Set {
    ys := <span class="fu">append</span>(xs,x)
    <span class="kw">return</span> (SetImpl)(ys)
}

<span class="kw">func</span> test0(x Set) <span class="dt">bool</span> {
    <span class="kw">return</span> x.isEmpty()
}

<span class="kw">func</span> test1() Set {
    xs := []<span class="dt">int</span>{}
    <span class="kw">return</span> (SetImpl)(xs)    
}</code></pre></div>
</div>
</body>
</html>
