<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Part 1: Go Basics + Higher-order functions + Lambda calculus</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Part 1: Go Basics + Higher-order functions + Lambda calculus</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="overview" class="slide section level1">
<h1>Overview</h1>
<ul>
<li>Introduction to Go (basics)</li>
<li>Higher-order functions</li>
<li>Lambda calculus (a bit of theory)</li>
</ul>
</div>
<div id="hello-world" class="slide section level1">
<h1>Hello World</h1>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">var</span> x <span class="dt">int</span>

<span class="kw">func</span> hi(y <span class="dt">int</span>) {
        fmt.Printf(<span class="st">&quot;hi %d</span><span class="ch">\n</span><span class="st">&quot;</span>,y)
}

<span class="kw">func</span> main() {
    x= <span class="dv">1</span>
    hi(x)
    fmt.Printf(<span class="st">&quot;hello, world</span><span class="ch">\n</span><span class="st">&quot;</span>)
}</code></pre></div>
<ul>
<li>Type declarations in 'proper' order
<ul>
<li><code>var varName varType</code></li>
<li>Variable <code>varName</code> of Type <code>varType</code></li>
</ul></li>
</ul>
</div>
<div id="go-toolchain" class="slide section level1">
<h1>Go Toolchain</h1>
<ul>
<li>Comand line:
<ul>
<li><p><code>go run hello.go</code></p></li>
<li><code>gofmt hello.go</code>
<ul>
<li>&quot;pretty printer&quot;</li>
<li>Per Default to standard I/O</li>
<li>Or bei overwriting content <code>gofmt -w hello.go</code></li>
</ul></li>
<li><p>Choose your editor (emacs, ...)</p></li>
</ul></li>
<li>IDE: <a href="IDE%20Go">http://code.google.com/p/liteide/</a></li>
</ul>
<p>In most cases, our programs consist of a single file.</p>
</div>
<div id="simple-form-of-type-inference" class="slide section level1">
<h1>Simple form of type inference</h1>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> main() {
    <span class="kw">var</span> x <span class="dt">int</span>
    x = <span class="dv">1</span>
    y := x + <span class="dv">1</span>
    fmt.Printf(<span class="st">&quot;y = %d&quot;</span>, y)

}</code></pre></div>
<p>The type of <code>y</code> is inferred by the right-hand side.</p>
<p>Pretty convenient!</p>
<p>Languages like Haskell support <em>full</em> type inference where the types of functions can be inferred.</p>
</div>
<div id="control-structures---for-loop" class="slide section level1">
<h1>Control structures - for loop</h1>
<p>The only control structure.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++ {
        fmt.Printf(<span class="st">&quot;Value of i is now: %d </span><span class="ch">\n</span><span class="st">&quot;</span>, i)
    }</code></pre></div>
<p>Infinite loop with <code>break</code></p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">for</span> {
        <span class="kw">if</span> j &gt; <span class="dv">5</span> {
            <span class="kw">break</span>
        }
        fmt.Printf(<span class="st">&quot;Value of j is now: %d </span><span class="ch">\n</span><span class="st">&quot;</span>, j)
        j++

    }</code></pre></div>
<h2 id="complete-example">Complete example</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> main() {

    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++ {
        fmt.Printf(<span class="st">&quot;Value of i is now: %d </span><span class="ch">\n</span><span class="st">&quot;</span>, i)
    }

    j := <span class="dv">0</span>
    <span class="kw">for</span> {
        <span class="kw">if</span> j &gt; <span class="dv">5</span> {
            <span class="kw">break</span>
        }
        fmt.Printf(<span class="st">&quot;Value of j is now: %d </span><span class="ch">\n</span><span class="st">&quot;</span>, j)
        j++

    }

}</code></pre></div>
</div>
<div id="strings" class="slide section level1">
<h1>Strings</h1>
<p>Unlike in C, Go strings are not null terminated. In Go, strings are represented by a struct consisting of</p>
<ol style="list-style-type: decimal">
<li><p>The length of the string.</p></li>
<li><p>A pointer to the first byte.</p></li>
</ol>
<p>These implementation details are hidden from the user. The user can make use of array notation to access a specific position in the string. There is a primitive <code>len</code> that computes the length of a string. Strings are immutable. This means they cannot be updated (but copied of course).</p>
<p>Next, we discuss a few examples that involve strings.</p>
<p>Printing a string.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">var</span> x <span class="dt">string</span> = <span class="st">&quot;Hello&quot;</span>
    y := <span class="st">&quot;Hi&quot;</span>

    fmt.Println(x)
    fmt.Printf(<span class="st">&quot;%s </span><span class="ch">\n</span><span class="st">&quot;</span>, y)</code></pre></div>
<p>Several ways to iterate over a string.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="fu">len</span>(x); i++ {
        fmt.Printf(<span class="st">&quot;%c&quot;</span>, x[i])

    }

    <span class="kw">for</span> i, _ := <span class="kw">range</span> x {
        fmt.Printf(<span class="st">&quot;%c&quot;</span>, x[i])

    }

    <span class="kw">for</span> _, e := <span class="kw">range</span> x {
        fmt.Printf(<span class="st">&quot;%c&quot;</span>, e)

    }</code></pre></div>
<p>Via <code>range</code> we obtain current position and element. The notation <code>_</code> indicates that we don't care about the value.</p>
</div>
<div id="arrays" class="slide section level1">
<h1>Arrays</h1>
<p>Out of bounds check.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">var</span> s1 [<span class="dv">3</span>]<span class="dt">string</span>
    s1[<span class="dv">0</span>] = <span class="st">&quot;one&quot;</span>
    s1[<span class="dv">1</span>] = <span class="st">&quot;two&quot;</span>
    s1[<span class="dv">2</span>] = <span class="st">&quot;three&quot;</span>
    <span class="co">// s1[3] = &quot;four&quot;</span></code></pre></div>
<p>Short-hand array initialization</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    s2 := [<span class="dv">3</span>]<span class="dt">string</span>{<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>}</code></pre></div>
<p>Iteration</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">for</span> index, elem := <span class="kw">range</span> s1 {
        fmt.Printf(<span class="st">&quot;%d %s </span><span class="ch">\n</span><span class="st">&quot;</span>, index, elem)
    }</code></pre></div>
<h2 id="complete-example-1">Complete example</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> main() {

    <span class="kw">var</span> s1 [<span class="dv">3</span>]<span class="dt">string</span>
    s1[<span class="dv">0</span>] = <span class="st">&quot;one&quot;</span>
    s1[<span class="dv">1</span>] = <span class="st">&quot;two&quot;</span>
    s1[<span class="dv">2</span>] = <span class="st">&quot;three&quot;</span>

    <span class="kw">for</span> index, elem := <span class="kw">range</span> s1 {
        fmt.Printf(<span class="st">&quot;%d %s </span><span class="ch">\n</span><span class="st">&quot;</span>, index, elem)
    }

    s2 := [<span class="dv">3</span>]<span class="dt">string</span>{<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>}

    fmt.Printf(<span class="st">&quot;%s&quot;</span>, s2[<span class="dv">0</span>])
}</code></pre></div>
</div>
<div id="slices" class="slide section level1">
<h1>Slices</h1>
<p>More flexible arrays (length may change)</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    s1 := <span class="fu">make</span>([]<span class="dt">string</span>, <span class="dv">3</span>)</code></pre></div>
<p>Short-hand</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    s2 := []<span class="dt">string</span>{<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>}</code></pre></div>
<p>Functions on slices, e.g. <code>append</code></p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    s2 := []<span class="dt">string</span>{<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>}
    s3 := <span class="fu">append</span>(s2, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>)</code></pre></div>
<h2 id="complete-example-2">Complete example</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> printSlice(s []<span class="dt">string</span>) {
    <span class="kw">for</span> _, elem := <span class="kw">range</span> s {
        fmt.Printf(<span class="st">&quot;%s </span><span class="ch">\n</span><span class="st">&quot;</span>, elem)
    }

}

<span class="kw">func</span> main() {

    s1 := <span class="fu">make</span>([]<span class="dt">string</span>, <span class="dv">3</span>)

    s1[<span class="dv">0</span>] = <span class="st">&quot;one&quot;</span>
    s1[<span class="dv">1</span>] = <span class="st">&quot;two&quot;</span>
    s1[<span class="dv">2</span>] = <span class="st">&quot;three&quot;</span>

    printSlice(s1)

    s2 := []<span class="dt">string</span>{<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>}

    s3 := <span class="fu">append</span>(s2, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>)

    printSlice(s3)
}</code></pre></div>
</div>
<div id="functions---return-values" class="slide section level1">
<h1>Functions - Return values</h1>
<ul>
<li>Return types in 'proper' order</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> inc(i <span class="dt">int</span>) <span class="dt">int</span></code></pre></div>
<ul>
<li>Multiple return values</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> myDiv2(x <span class="dt">int</span>, y <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>)</code></pre></div>
<ul>
<li>Complete example</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> inc(i <span class="dt">int</span>) <span class="dt">int</span> { <span class="kw">return</span> i + <span class="dv">1</span> }

<span class="co">// Direct reference to return values by name</span>
<span class="kw">func</span> myDiv(x <span class="dt">int</span>, y <span class="dt">int</span>) (res <span class="dt">int</span>, status <span class="dt">bool</span>) {
    status = <span class="ot">false</span>
    <span class="kw">if</span> y == <span class="dv">0</span> {
        <span class="kw">return</span>
    }
    res = x / y
    status = <span class="ot">true</span>
    <span class="kw">return</span>
}

<span class="kw">func</span> myDiv2(x <span class="dt">int</span>, y <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) {
    <span class="kw">if</span> y == <span class="dv">0</span> {
        <span class="kw">return</span> <span class="dv">0</span>, <span class="ot">false</span>
    }
    <span class="kw">return</span> x / y, <span class="ot">true</span>
}

<span class="kw">func</span> main() {
    <span class="kw">var</span> res <span class="dt">int</span>
    <span class="kw">var</span> status <span class="dt">bool</span>
    res, status = myDiv(inc(<span class="dv">3</span>), <span class="dv">2</span>)
    fmt.Printf(<span class="st">&quot;Result = %d </span><span class="ch">\n</span><span class="st">&quot;</span>, res)
    fmt.Printf(<span class="st">&quot;Status = %t </span><span class="ch">\n</span><span class="st">&quot;</span>, status)

    res, status = myDiv2(<span class="dv">1</span>, <span class="dv">0</span>)
    fmt.Printf(<span class="st">&quot;Result = %d </span><span class="ch">\n</span><span class="st">&quot;</span>, res)
    fmt.Printf(<span class="st">&quot;Status = %t </span><span class="ch">\n</span><span class="st">&quot;</span>, status)
}</code></pre></div>
</div>
<div id="strings-again" class="slide section level1">
<h1>Strings again</h1>
<p>We write a function to split a string into a prefix and a suffix once we see given byte.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> splitAt(x <span class="dt">string</span>, b <span class="dt">byte</span>) (<span class="dt">string</span>, <span class="dt">string</span>) {
    <span class="kw">var</span> r1, r2 []<span class="dt">byte</span>
    suffix := <span class="ot">false</span>

    <span class="kw">for</span> i, _ := <span class="kw">range</span> x {
        <span class="kw">if</span> !suffix {
            <span class="kw">if</span> x[i] == b {
                suffix = <span class="ot">true</span>
            } <span class="kw">else</span> {
                r1 = <span class="fu">append</span>(r1, x[i])
            }

        } <span class="kw">else</span> {
            r2 = <span class="fu">append</span>(r2, x[i])
        }
    }

    s1 := (<span class="dt">string</span>)(r1)
    s2 := (<span class="dt">string</span>)(r2)

    <span class="kw">return</span> s1, s2

}</code></pre></div>
<p>We use slices r1 and r2 to collect the prefix and suffix. We check if we have seen the given element b yet, and then append elements in the original string to either r1 or 2. The element b is not added.</p>
<p>We require slices as append only operates on slices. As we wish to retrieve the result as strings, we need to include a type conversion.</p>
<p>Function splitAt returns two results, the prefix and the suffix. Multiple return results can be retrieved as follows.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    r1, r2 := splitAt(<span class="st">&quot;hel:lo&quot;</span>, &#39;:&#39;)

    fmt.Printf(<span class="st">&quot;%s %s&quot;</span>, r1, r2)</code></pre></div>
</div>
<div id="higher-order-functions" class="slide section level1">
<h1>Higher-order functions</h1>
<p>Simple (increment) function.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> inc(i <span class="dt">int</span>) <span class="dt">int</span> { <span class="kw">return</span> i + <span class="dv">1</span> }</code></pre></div>
<p>Functions can be arguments.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> apply(i <span class="dt">int</span>, f <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> f(i)
    }


<span class="kw">func</span> mapInt(f <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span>, xs []<span class="dt">int</span>) []<span class="dt">int</span> {
    <span class="kw">for</span> i, e := <span class="kw">range</span> xs {
        xs[i] = f(e)
    }

    <span class="kw">return</span> xs
}</code></pre></div>
<p>Functions can be return values.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> hello2(x <span class="dt">int</span>) <span class="kw">func</span>() {
    <span class="kw">return</span> <span class="kw">func</span>() { fmt.Printf(<span class="st">&quot;Hello %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x) }
}</code></pre></div>
<p>Point to note. We introduce here an annonymous function (a &quot;lambda&quot;) via the keyword <code>func</code>.</p>
<h2 id="complete-example-3">Complete example</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> inc(i <span class="dt">int</span>) <span class="dt">int</span> { <span class="kw">return</span> i + <span class="dv">1</span> }

<span class="kw">func</span> apply(i <span class="dt">int</span>, f <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> f(i)
}

<span class="kw">func</span> execute(f <span class="kw">func</span>()) {
    f()
}

<span class="kw">func</span> hello() {
    fmt.Print(<span class="st">&quot;Hello </span><span class="ch">\n</span><span class="st">&quot;</span>)
}

<span class="kw">func</span> hello2(x <span class="dt">int</span>) <span class="kw">func</span>() {
    <span class="kw">return</span> <span class="kw">func</span>() { fmt.Printf(<span class="st">&quot;Hello %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x) }
}

<span class="kw">func</span> mapInt(f <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span>, xs []<span class="dt">int</span>) []<span class="dt">int</span> {
    <span class="kw">for</span> i, e := <span class="kw">range</span> xs {
        xs[i] = f(e)
    }

    <span class="kw">return</span> xs
}

<span class="kw">func</span> main() {
    execute(hello)

    execute(hello2(<span class="dv">2</span>))

    fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, apply(<span class="dv">1</span>, inc))

    xs := []<span class="dt">int</span>{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}
    ys := mapInt(inc, xs)
    zs := mapInt(<span class="kw">func</span>(i <span class="dt">int</span>) <span class="dt">int</span> { <span class="kw">return</span> i + <span class="dv">1</span> }, xs)

    fmt.Printf(<span class="st">&quot;%d %d </span><span class="ch">\n</span><span class="st">&quot;</span>, ys[<span class="dv">0</span>], zs[<span class="dv">0</span>])

}</code></pre></div>
</div>
<div id="partial-function-application" class="slide section level1">
<h1>Partial function application</h1>
<p>Consider</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> plus(x <span class="dt">int</span>, y <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> x+y
}</code></pre></div>
<p>The arguments to <code>plus</code> must be both present.</p>
<p>In Go, it's possible to 'incrementally' supply addition with its arguments.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> add(x <span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> <span class="kw">func</span>(y <span class="dt">int</span>) <span class="dt">int</span> { <span class="kw">return</span> x + y }
}</code></pre></div>
<p>Function <code>add</code> expects an integer argument (left operand) and yields a function. This function expects another integer argument (right operand) and then yields the expected result.</p>
<p>Being able to supply function arguments incrementally gives us more flexibility. Here is a neat way to define the increment function.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> inc(x <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> add(<span class="dv">1</span>)(x)
}</code></pre></div>
<ul>
<li><p>`add(1) yields a function from integer to integer</p></li>
<li><p><code>add(1)(x)</code> then yields the incremented <code>x</code> value</p></li>
</ul>
<p>Slight variation of the above.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    plus := <span class="kw">func</span>(x <span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span> {
        <span class="kw">return</span> <span class="kw">func</span>(y <span class="dt">int</span>) <span class="dt">int</span> { <span class="kw">return</span> x + y }
    }


    inc := plus(<span class="dv">1</span>)</code></pre></div>
<h2 id="connection-to-oo">Connection to OO</h2>
<p>In Go functions are first-class (that is, they can appear anywwhere). This is similar to OO where objects are first-class.</p>
<p>For example, in an OO language, we can call a method <code>m1</code> on some object <code>o1</code>. The result is an object on which we call another method <code>m2</code>.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">o1.m1().m2()</code></pre></div>
<h2 id="currying">Currying</h2>
<p>Is there a difference?</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> plus1(x <span class="dt">int</span>, y <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> x + y
}

<span class="kw">func</span> plus2(x <span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> <span class="kw">func</span>(y <span class="dt">int</span>) <span class="dt">int</span> {
        <span class="kw">return</span> x + y
    }
}</code></pre></div>
<p>How to transform one function into the other?</p>
<h3 id="complete-source-code">Complete source code</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> plus1(x <span class="dt">int</span>, y <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> x + y
}

<span class="kw">func</span> plus2(x <span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> <span class="kw">func</span>(y <span class="dt">int</span>) <span class="dt">int</span> {
        <span class="kw">return</span> x + y
    }
}

<span class="kw">func</span> curry(f <span class="kw">func</span>(<span class="dt">int</span>, <span class="dt">int</span>) <span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> <span class="kw">func</span>(x <span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span> {
        <span class="kw">return</span> <span class="kw">func</span>(y <span class="dt">int</span>) <span class="dt">int</span> {
            <span class="kw">return</span> f(x, y)
        }
    }

}

<span class="kw">func</span> uncurry(g <span class="kw">func</span>(<span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">int</span>) <span class="kw">func</span>(<span class="dt">int</span>, <span class="dt">int</span>) <span class="dt">int</span> {
    <span class="kw">return</span> <span class="kw">func</span>(x <span class="dt">int</span>, y <span class="dt">int</span>) <span class="dt">int</span> {
        <span class="kw">return</span> (g(x))(y)
    }
}

<span class="kw">func</span> main() {

    x1 := plus1(<span class="dv">1</span>, <span class="dv">2</span>)
    x2 := (plus2(<span class="dv">1</span>))(<span class="dv">2</span>)
    p := uncurry(plus2)
    x3 := p(<span class="dv">1</span>, <span class="dv">2</span>)
    p2 := curry(plus1)
    x4 := (p2(<span class="dv">1</span>))(<span class="dv">2</span>)

    fmt.Printf(<span class="st">&quot;%d %d %d %d&quot;</span>, x1, x2, x3, x4)

}</code></pre></div>
</div>
<div id="function-closures" class="slide section level1">
<h1>Function closures</h1>
<p>What's the output of the following program?</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">type</span> Type0 <span class="kw">func</span>()

<span class="kw">func</span> main() {
    <span class="kw">var</span> fn Type0
    <span class="kw">var</span> x <span class="dt">int</span> = <span class="dv">2</span>

    fn = <span class="kw">func</span>() { fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, x) }

    fn()

    x = <span class="dv">3</span>
    fn()
}</code></pre></div>
<p>For each call to <code>fn</code> there is a different result!</p>
<p>Unlike <em>pure</em> functional programming languages, the Go language is <em>impure</em>. Pure means that for each function call and the same input arguments, we obtain the same output. This is also referred to as <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>.</p>
</div>
<div id="type-definitions-and-structs-named-types" class="slide section level1">
<h1>Type definitions and structs (named types)</h1>
<h2 id="type-definitions">Type definitions</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> myint <span class="dt">int</span></code></pre></div>
<p>Introduces a new type named <code>myint</code>. Values of type <code>int</code> and <code>myint</code> cannot be mixed.</p>
<p>The type <code>myint</code> is structurally isomorphic to <code>int</code>, so we can (type) convert one into the other.</p>
<p>Here is the complete example.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">type</span> myint <span class="dt">int</span>

<span class="kw">func</span> main() {
    <span class="kw">var</span> i <span class="dt">int</span>
    <span class="kw">var</span> j myint

    j = <span class="dv">1</span>

    i = (<span class="dt">int</span>)(j)
    <span class="co">// i = j</span>
        <span class="co">// yields a type error</span>

    j = (myint)(i)

    fmt.Printf(<span class="st">&quot;%d&quot;</span>, i)
}</code></pre></div>
<h2 id="structs">Structs</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> rectangle <span class="kw">struct</span> {
    length <span class="dt">int</span>
    width  <span class="dt">int</span>
}</code></pre></div>
<p>Defines a named type <code>rectangle</code> that is structurally isomorphic to a struct of two ints where both ints can be accessed via field labels.</p>
<p>Construction of values.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">var</span> r1 rectangle = rectangle{<span class="dv">1</span>, <span class="dv">2</span>}
    <span class="kw">var</span> r2 rectangle = rectangle{width: <span class="dv">2</span>, length: <span class="dv">1</span>}
    r3 := rectangle{width: <span class="dv">2</span>, length: <span class="dv">1</span>}</code></pre></div>
<p>Either by position or by field reference.</p>
</div>
<div id="intermediate-summary" class="slide section level1">
<h1>Intermediate Summary</h1>
<ul>
<li><p>Control structures</p></li>
<li><p>Arrays, slices</p></li>
<li>Functions
<ul>
<li>Higher-order</li>
<li>Multiple return values</li>
</ul></li>
<li>Structs
<ul>
<li>OO style programming</li>
</ul></li>
</ul>
</div>
<div id="some-simple-exercises" class="slide section level1">
<h1>Some (simple) exercises</h1>
<p>Play with the examples provided.</p>
<h2 id="any-map-filter-...">any, map, filter, ...</h2>
<p>Implement the following functions. Sample solutions below.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="co">// Yields the first element which satisfies the predicate.</span>
<span class="co">// Otherwise, we return a dummy element.</span>
<span class="co">// The first component of the resulting tuple indicates</span>
<span class="co">// if any element has satisfied the predicate.</span>
<span class="kw">func</span> any(p <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">bool</span>,xs []<span class="dt">int</span>) (<span class="dt">bool</span>,<span class="dt">int</span>)


<span class="co">// Map f over a list of integer values which then yields</span>
<span class="co">// a list of booleans</span>
<span class="kw">func</span> <span class="kw">map</span>(f <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">bool</span>,xs []<span class="dt">int</span>) []<span class="dt">bool</span>


<span class="co">// Filter out all elemements which satisfy the predicate.</span>
<span class="kw">func</span> filter(p <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">bool</span>,xs []<span class="dt">int</span>) []<span class="dt">int</span></code></pre></div>
<h3 id="sample-solution">Sample solution</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="co">// Yields the first element which satisfies the predicate.</span>
<span class="co">// Otherwise, we return a dummy element.</span>
<span class="co">// The first component of the resulting tuple indicates</span>
<span class="co">// if any element has satisfied the predicate.</span>
<span class="kw">func</span> any(p <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">bool</span>, xs []<span class="dt">int</span>) (<span class="dt">bool</span>, <span class="dt">int</span>) {
    <span class="kw">for</span> _, x := <span class="kw">range</span> xs {
        <span class="kw">if</span> p(x) {
            <span class="kw">return</span> <span class="ot">true</span>, x
        }
    }
    <span class="kw">return</span> <span class="ot">false</span>, -<span class="dv">1</span>
}

<span class="co">// Map f over a list of integer values which then yields</span>
<span class="co">// a list of booleans</span>
<span class="co">// &#39;map&#39; predefined so use mapMy</span>
<span class="kw">func</span> mapMy(f <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">bool</span>, xs []<span class="dt">int</span>) []<span class="dt">bool</span> {
    <span class="kw">var</span> ys []<span class="dt">bool</span>

    <span class="kw">for</span> _, x := <span class="kw">range</span> xs {
        ys = <span class="fu">append</span>(ys, f(x))

    }
    <span class="kw">return</span> ys
}

<span class="co">// Filter out all elemements which satisfy the predicate.</span>
<span class="kw">func</span> filter(p <span class="kw">func</span>(<span class="dt">int</span>) <span class="dt">bool</span>, xs []<span class="dt">int</span>) []<span class="dt">int</span> {
    <span class="kw">var</span> ys []<span class="dt">int</span>

    <span class="kw">for</span> _, x := <span class="kw">range</span> xs {
        <span class="kw">if</span> p(x) {
            ys = <span class="fu">append</span>(ys, x)
        }
    }
    <span class="kw">return</span> ys
}

<span class="kw">func</span> main() {
    b, x := any(<span class="kw">func</span>(x <span class="dt">int</span>) <span class="dt">bool</span> { <span class="kw">return</span> x &gt; <span class="dv">1</span> }, []<span class="dt">int</span>{<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>})

    fmt.Printf(<span class="st">&quot;%b %d </span><span class="ch">\n</span><span class="st">&quot;</span>, b, x)

    xs := filter(<span class="kw">func</span>(x <span class="dt">int</span>) <span class="dt">bool</span> { <span class="kw">return</span> x &gt; <span class="dv">1</span> }, []<span class="dt">int</span>{<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>})

    <span class="kw">for</span> _, x := <span class="kw">range</span> xs {
        fmt.Printf(<span class="st">&quot;%d </span><span class="ch">\n</span><span class="st">&quot;</span>, x)
    }

}</code></pre></div>
</div>
<div id="lambda-calculus" class="slide section level1">
<h1>Lambda calculus</h1>
<p>The lambda calculus represents a minimal core language just consisting of functions.</p>
<p>Functions are first-class (can appear as arguments and as return values). Think of first-class objects!</p>
<h2 id="lambda-calculus-syntax-and-semantics">Lambda calculus: Syntax and semantics</h2>
<p>Terms (expressions/programs) in the lambda calculus are defined by the following (abstract) EBNF syntax.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%0A%20t%20%5C%20%5C%20%3A%3A%3D%20%5C%20%5C%20x%20%5C%20%5C%20%5Cmid%20%5C%20%5C%20%5Clambda%20x.t%20%5C%20%5C%20%5Cmid%20%5C%20%5C%20t%20%5C%20t%20%0A" alt="
 t \ \ ::= \ \ x \ \ \mid \ \ \lambda x.t \ \ \mid \ \ t \ t 
" title="
 t \ \ ::= \ \ x \ \ \mid \ \ \lambda x.t \ \ \mid \ \ t \ t 
" /><br /></p>
<p>where</p>
<ul>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> refers to a variable</li>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.t" alt="\lambda x.t" title="\lambda x.t" /> to a lambda abstraction</li>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t%20%5C%20t" alt="t \ t" title="t \ t" /> refers to a function application</li>
</ul>
<p>The above EBNF is ambiguous. For example, consider expression <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.x%20%5C%20x" alt="\lambda x.x \ x" title="\lambda x.x \ x" />. Based on the above EBNF rules there are two possible interpretations.</p>
<ol style="list-style-type: decimal">
<li><p>A lambda function with formal parameter <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> is applied to itself in the function body.</p></li>
<li><p>The identity function <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.x" alt="\lambda x.x" title="\lambda x.x" /> applied to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />.</p></li>
</ol>
<p>The first interpretation can be explained via the following (parse tree) derivation <br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%0At%20%5Crightarrow%20%5Clambda%20x.t%20%5Crightarrow%20%5Clambda%20x.%20t%20%5C%20t%20%5Crightarrow%20%5Clambda%20x.%20x%20%5C%20t%20%5Crightarrow%20%5Clambda%20x.x%20%5C%20x%0A" alt="
t \rightarrow \lambda x.t \rightarrow \lambda x. t \ t \rightarrow \lambda x. x \ t \rightarrow \lambda x.x \ x
" title="
t \rightarrow \lambda x.t \rightarrow \lambda x. t \ t \rightarrow \lambda x. x \ t \rightarrow \lambda x.x \ x
" /><br /></p>
<p>whereas for the second derivation we find <br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%0At%20%5Crightarrow%20t%20%5C%20t%20%5Crightarrow%20%28%5Clambda%20x.%20t%29%20%5C%20t%20%5Crightarrow%20%28%5Clambda%20x.x%29%20%5C%20t%20%5Crightarrow%20%28%5Clambda%20x.x%29%20%5C%20x%0A" alt="
t \rightarrow t \ t \rightarrow (\lambda x. t) \ t \rightarrow (\lambda x.x) \ t \rightarrow (\lambda x.x) \ x
" title="
t \rightarrow t \ t \rightarrow (\lambda x. t) \ t \rightarrow (\lambda x.x) \ t \rightarrow (\lambda x.x) \ x
" /><br /></p>
<p>In the above derivation, parantheses &quot;(..)&quot; are meta-symbols to highlight the difference among the two derivations.</p>
<p>In examples, we therefore may make use of parantheses to avoid ambiguities, for example <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.x%29%20%5C%20x" alt="(\lambda x.x) \ x" title="(\lambda x.x) \ x" />.</p>
<p>The operational semantics of the lambda calculus is defined via a single rule, commonly referred to as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbeta" alt="\beta" title="\beta" />-reduction.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%0A%20%28%5Clambda%20x.%20t_1%29%20%5C%20t_2%20%5Crightarrow%20%5Bt_2%2Fx%5Dt_1%0A" alt="
 (\lambda x. t_1) \ t_2 \rightarrow [t_2/x]t_1
" title="
 (\lambda x. t_1) \ t_2 \rightarrow [t_2/x]t_1
" /><br /></p>
<p>In <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Bt_2%2Fx%5Dt_1" alt="[t_2/x]t_1" title="[t_2/x]t_1" />, we apply the substitution <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Bt_2%2Fx%5D" alt="[t_2/x]" title="[t_2/x]" />: In the body <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_1" alt="t_1" title="t_1" />, replace each occurence of the formal parameter <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> by the argument <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_2" alt="t_2" title="t_2" />.</p>
<p>Commonly, we refer to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.e" alt="\lambda x.e" title="\lambda x.e" /> as a lambda-abstraction and to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x" alt="\lambda x" title="\lambda x" /> as the lambda-binding.</p>
<p>For example, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20%28%5Clambda%20y.%20y%29%29%20%5C%20z" alt="(\lambda x. (\lambda y. y)) \ z" title="(\lambda x. (\lambda y. y)) \ z" /> reduces to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20y.y" alt="\lambda y.y" title="\lambda y.y" />.</p>
<p>As it is common in programming languages, we can reuse the same variable names and apply the common rule that each use of a variable name refers to the closest binding site. For example, consider <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.%20%28%5Clambda%20x.%20x%29" alt="\lambda x. (\lambda x. x)" title="\lambda x. (\lambda x. x)" /> where the innermost occurence of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> refers to the inner lambda-binding.</p>
<p>Via some simply renaming we can always guarantee that variables are distinct. For example, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.%20%28%5Clambda%20x.%20x%29" alt="\lambda x. (\lambda x. x)" title="\lambda x. (\lambda x. x)" /> can be renamed to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.%20%28%5Clambda%20y.%20y%29" alt="\lambda x. (\lambda y. y)" title="\lambda x. (\lambda y. y)" />.</p>
<p>We generally assume that lambda-bindings always introduce fresh, distinct variables.</p>
<h2 id="details">Details</h2>
<h3 id="syntactic-sugar">Syntactic sugar</h3>
<p>Function application is left associative. Hence, the term <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20u.u%29%20%5C%20z%20%5C%20x" alt="(\lambda u.u) \ z \ x" title="(\lambda u.u) \ z \ x" /> is a short-hand for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%28%28%5Clambda%20u.u%29%20%5C%20z%29%20%5C%20x%29" alt="(((\lambda u.u) \ z) \ x)" title="(((\lambda u.u) \ z) \ x)" />.</p>
<p>The body of a lambda abstractions extends to the right as long as possible. Hence, the term <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20z.%20%28%5Clambda%20u.u%29%20%5C%20z%20%5C%20x" alt="\lambda z. (\lambda u.u) \ z \ x" title="\lambda z. (\lambda u.u) \ z \ x" /> is a short-hand for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20z.%20%28%28%28%5Clambda%20u.u%29%20%5C%20z%29%20%5C%20x%29" alt="\lambda z. (((\lambda u.u) \ z) \ x)" title="\lambda z. (((\lambda u.u) \ z) \ x)" />.</p>
<h3 id="free-variables">Free variables</h3>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=fv%28t%29" alt="fv(t)" title="fv(t)" /> computes all free variables in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" />, i.e. those variables which are not bound by a lambda abstraction.</p>
<p>The definition by induction over the structure of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" /> is as follows:</p>
<ul>
<li>$fv(x) = { x } $</li>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=fv%28%5Clambda%20x.t%29%20%3D%20fv%28t%29%20-%20%5C%7B%20x%20%5C%7D" alt="fv(\lambda x.t) = fv(t) - \{ x \}" title="fv(\lambda x.t) = fv(t) - \{ x \}" /></li>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=fv%28t_1%20%5C%20t_2%29%20%3D%20fv%28t_1%29%20%5Ccup%20fv%28t_2%29" alt="fv(t_1 \ t_2) = fv(t_1) \cup fv(t_2)" title="fv(t_1 \ t_2) = fv(t_1) \cup fv(t_2)" /></li>
</ul>
<p>In case of name clashes we must rename bound variables. Consider <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5By%20%5C%20%28%5Clambda%20x.x%29%2Fx%5D%20%5Clambda%20y.%28%5Clambda%20x.x%29%20%5C%20y%20%5C%20x" alt="[y \ (\lambda x.x)/x] \lambda y.(\lambda x.x) \ y \ x" title="[y \ (\lambda x.x)/x] \lambda y.(\lambda x.x) \ y \ x" />:</p>
<ol style="list-style-type: decimal">
<li>Renaming yields: <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5By%20%5C%20%28%5Clambda%20v.v%29%2Fx%5D%20%5Clambda%20z.%20%28%5Clambda%20u.u%29%20%5C%20z%20%5C%20x" alt="[y \ (\lambda v.v)/x] \lambda z. (\lambda u.u) \ z \ x" title="[y \ (\lambda v.v)/x] \lambda z. (\lambda u.u) \ z \ x" /></li>
<li>Substitution without name clashes yields: <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20z.%20%28%5Clambda%20u.u%29%20%5C%20z%28y%20%5C%20%28%5Clambda%20v.v%29%29" alt="\lambda z. (\lambda u.u) \ z(y \ (\lambda v.v))" title="\lambda z. (\lambda u.u) \ z(y \ (\lambda v.v))" /></li>
</ol>
<h3 id="substitution">Substitution</h3>
<p>Examples (where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> refers to a term/expression)</p>
<ul>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5B%20e_1%2Fx%20%5D%20x%20%3D%20e_1" alt="[ e_1/x ] x = e_1" title="[ e_1/x ] x = e_1" /></li>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5B%20e_1%2Fx%20%5D%20y%20%3D%20y" alt="[ e_1/x ] y = y" title="[ e_1/x ] y = y" /> if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y%20%5Cnot%3D%20x" alt="y \not= x" title="y \not= x" /></li>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5B%20e_1%20%2F%20x%20%5D%20e_2%20%5C%20e_3%20%3D%20%28%5B%20e_1%20%2Fx%20%5D%20e_2%29%20%5C%20%28%5B%20e_1%20%2Fx%20%5D%20e_3%29" alt="[ e_1 / x ] e_2 \ e_3 = ([ e_1 /x ] e_2) \ ([ e_1 /x ] e_3)" title="[ e_1 / x ] e_2 \ e_3 = ([ e_1 /x ] e_2) \ ([ e_1 /x ] e_3)" /></li>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5B%20e_1%20%2F%20x%20%5D%20%5Clambda%20y.e_2%20%3D%20%5Clambda%20y.%20%5B%20e_1%20%2Fx%20%5D%20e_2" alt="[ e_1 / x ] \lambda y.e_2 = \lambda y. [ e_1 /x ] e_2" title="[ e_1 / x ] \lambda y.e_2 = \lambda y. [ e_1 /x ] e_2" /> if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y%20%5Cnot%20%3D%20x" alt="y \not = x" title="y \not = x" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y%5Cnot%5Cin%20fv%28e_1%29" alt="y\not\in fv(e_1)" title="y\not\in fv(e_1)" /></li>
</ul>
<h3 id="evaluation-strategies">Evaluation strategies</h3>
<p>There are two principles ways how to evaluate terms:</p>
<ul>
<li>Innermost first</li>
<li>Outermost first</li>
</ul>
<h4 id="innermost">Innermost</h4>
<ul>
<li>Look for a redex innermost, leftmost</li>
<li>Also called Applicative Order Reduction (AOR)</li>
<li>Redex = reducible expression of the form <code>(\x-&gt; ...) e</code></li>
</ul>
<p><em>Call-by value (CBV)</em> = AOR with the exception that we don't evaluate under &quot;lambda&quot; (i.e. inside function bodies)</p>
<h4 id="outermost">Outermost</h4>
<p>Outermost, leftmost, also called Normal Order Reduction (NOR)</p>
<p><em>Call-by name (CBN)</em> = NOR with the exception that we don't evaluate under &quot;lambda&quot; (i.e. inside function bodies)</p>
<h4 id="examples">Examples</h4>
<p>We consider evaluation of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20f.%5Clambda%20x.%20f%20%5C%20%28f%20%5C%20x%29%29%20%28%28%5Clambda%20x.x%29%20%28%5Clambda%20x.x%29%29" alt="(\lambda f.\lambda x. f \ (f \ x)) ((\lambda x.x) (\lambda x.x))" title="(\lambda f.\lambda x. f \ (f \ x)) ((\lambda x.x) (\lambda x.x))" /> where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow" alt="\rightarrow" title="\rightarrow" /> denotes an evaluation step</p>
<p>Call-by-name (CBN)</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20f.%5Clambda%20x.%20f%20%5C%20%28f%20%5C%20x%29%29%20%28%28%5Clambda%20x.x%29%20%28%5Clambda%20x.x%29%29" alt="(\lambda f.\lambda x. f \ (f \ x)) ((\lambda x.x) (\lambda x.x))" title="(\lambda f.\lambda x. f \ (f \ x)) ((\lambda x.x) (\lambda x.x))" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5Clambda%20x.%28%5Clambda%20x.x%29%28%5Clambda%20x.x%29%28%28%5Clambda%20x.x%29%28%5Clambda%20x.x%29x%29" alt="\rightarrow \lambda x.(\lambda x.x)(\lambda x.x)((\lambda x.x)(\lambda x.x)x)" title="\rightarrow \lambda x.(\lambda x.x)(\lambda x.x)((\lambda x.x)(\lambda x.x)x)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5Clambda%20x.%28%5Clambda%20x.x%29%28%28%5Clambda%20x.x%29x%29" alt="\rightarrow \lambda x.(\lambda x.x)((\lambda x.x)x)" title="\rightarrow \lambda x.(\lambda x.x)((\lambda x.x)x)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5Clambda%20x.%28%5Clambda%20x.x%29x" alt="\rightarrow \lambda x.(\lambda x.x)x" title="\rightarrow \lambda x.(\lambda x.x)x" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5Clambda%20x.x" alt="\rightarrow \lambda x.x" title="\rightarrow \lambda x.x" /></p>
<p>Call-by-value (CBV):</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20f.%5Clambda%20x.%20f%20%5C%20%28f%20%5C%20x%29%29%20%28%28%5Clambda%20x.x%29%20%28%5Clambda%20x.x%29%29" alt="(\lambda f.\lambda x. f \ (f \ x)) ((\lambda x.x) (\lambda x.x))" title="(\lambda f.\lambda x. f \ (f \ x)) ((\lambda x.x) (\lambda x.x))" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%28%5Clambda%20f.%5Clambda%20x.%20f%20%5C%20%28f%20%5C%20x%29%29%20%28%5Clambda%20x.x%29" alt="\rightarrow (\lambda f.\lambda x. f \ (f \ x)) (\lambda x.x)" title="\rightarrow (\lambda f.\lambda x. f \ (f \ x)) (\lambda x.x)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5Clambda%20x.%28%5Clambda%20x.x%29%20%28%28%5Clambda%20x.x%29%20x%29" alt="\rightarrow \lambda x.(\lambda x.x) ((\lambda x.x) x)" title="\rightarrow \lambda x.(\lambda x.x) ((\lambda x.x) x)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5Clambda%20x.%28%5Clambda%20x.x%29x" alt="\rightarrow \lambda x.(\lambda x.x)x" title="\rightarrow \lambda x.(\lambda x.x)x" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5Clambda%20x.x" alt="\rightarrow \lambda x.x" title="\rightarrow \lambda x.x" /></p>
<h4 id="nontermination">(Non)Termination</h4>
<p>There are lambda terms whose evaluation will not terminate:</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20%28x%20%5C%20x%29%29%20%28%5Clambda%20x.%20%28x%20%5C%20x%29%29" alt="(\lambda x. (x \ x)) (\lambda x. (x \ x))" title="(\lambda x. (x \ x)) (\lambda x. (x \ x))" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%28%5Clambda%20x.%20%28x%20%5C%20x%29%29%20%28%5Clambda%20x.%20%28x%20%5C%20x%29%29" alt="\rightarrow (\lambda x. (x \ x)) (\lambda x. (x \ x))" title="\rightarrow (\lambda x. (x \ x)) (\lambda x. (x \ x))" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%28%5Clambda%20x.%20%28x%20%5C%20x%29%29%20%28%5Clambda%20x.%20%28x%20%5C%20x%29%29" alt="\rightarrow (\lambda x. (x \ x)) (\lambda x. (x \ x))" title="\rightarrow (\lambda x. (x \ x)) (\lambda x. (x \ x))" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20..." alt="\rightarrow ..." title="\rightarrow ..." /></p>
<p>Termination under CBN is more likely than termination under CBV.</p>
<p>Let's abbreviate <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20%28x%20%5C%20x%29%29%20%28%5Clambda%20x.%20%28x%20%5C%20x%29%29" alt="(\lambda x. (x \ x)) (\lambda x. (x \ x))" title="(\lambda x. (x \ x)) (\lambda x. (x \ x))" /> by <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5COmega" alt="\Omega" title="\Omega" />. Then, the lambda term <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20%5Clambda%20y.%20x%29%20%5COmega" alt="(\lambda x. \lambda y. x) \Omega" title="(\lambda x. \lambda y. x) \Omega" /> terminates under CBN but <em>not</em> under CBV.</p>
<h4 id="short-summary">Short summary</h4>
<ul>
<li>CBN seems rather inefficient</li>
<li>But has plenty of applications
<ul>
<li>More code reuse</li>
<li>More declarative code</li>
<li>Infinite, circular data structures</li>
<li>...</li>
</ul></li>
</ul>
<p>More details in some upcoming exercises.</p>
<h3 id="further-examples">Further examples</h3>
<p>Consider <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20x%20%5C%20y%29%20%5C%20%28%5Clambda%20x.%20x%29%20%5C%20%28%5Clambda%20x.%20x%29" alt="(\lambda x. x \ y) \ (\lambda x. x) \ (\lambda x. x)" title="(\lambda x. x \ y) \ (\lambda x. x) \ (\lambda x. x)" />.</p>
<p>Function application is left-associative, therefore, the meaning of the above lambda term is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%28%5Clambda%20x.%20x%20%5C%20y%29%20%5C%20%28%5Clambda%20x.%20x%29%29%20%5C%20%28%5Clambda%20x.%20x%29" alt="((\lambda x. x \ y) \ (\lambda x. x)) \ (\lambda x. x)" title="((\lambda x. x \ y) \ (\lambda x. x)) \ (\lambda x. x)" />.</p>
<p>Let's carry out the evaluation steps.</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%28%5Clambda%20x.%20x%20%5C%20y%29%20%5C%20%28%5Clambda%20x.%20x%29%29%20%5C%20%28%5Clambda%20x.%20x%29" alt="((\lambda x. x \ y) \ (\lambda x. x)) \ (\lambda x. x)" title="((\lambda x. x \ y) \ (\lambda x. x)) \ (\lambda x. x)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D_%7BRenaming%7D%20%5C%20%5C%20%28%28%5Clambda%20x_1.%20x_1%20%5C%20y%29%20%5C%20%28%5Clambda%20x_2.%20x_2%29%29%20%5C%20%28%5Clambda%20x_3.%20x_3%29" alt="=_{Renaming} \ \ ((\lambda x_1. x_1 \ y) \ (\lambda x_2. x_2)) \ (\lambda x_3. x_3)" title="=_{Renaming} \ \ ((\lambda x_1. x_1 \ y) \ (\lambda x_2. x_2)) \ (\lambda x_3. x_3)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%20%5C%20%28%20%28%5Clambda%20x_2.%20x_2%29%20%5C%20y%29%20%28%5Clambda%20x_3.%20x_3%29" alt="\rightarrow \ \ ( (\lambda x_2. x_2) \ y) (\lambda x_3. x_3)" title="\rightarrow \ \ ( (\lambda x_2. x_2) \ y) (\lambda x_3. x_3)" /> because <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x_1.%20x_1%20%5C%20y%29%20%5C%20%28%5Clambda%20x_2.%20x_2%29%20%5C%20%5Crightarrow%20%5C%20%5B%28%5Clambda%20x_2.%20x_2%29%20%2F%20x_1%20%5D%20%28x_1%20%5C%20y%29%20%5C%20%3D%20%5C%20%20%28%5Clambda%20x_2.%20x_2%29%20%5C%20y" alt="(\lambda x_1. x_1 \ y) \ (\lambda x_2. x_2) \ \rightarrow \ [(\lambda x_2. x_2) / x_1 ] (x_1 \ y) \ = \  (\lambda x_2. x_2) \ y" title="(\lambda x_1. x_1 \ y) \ (\lambda x_2. x_2) \ \rightarrow \ [(\lambda x_2. x_2) / x_1 ] (x_1 \ y) \ = \  (\lambda x_2. x_2) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%20%5C%20y%20%5C%20%28%5Clambda%20x_3.%20x_3%29" alt="\rightarrow \ \ y \ (\lambda x_3. x_3)" title="\rightarrow \ \ y \ (\lambda x_3. x_3)" /> because <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x_2.%20x_2%29%20%5C%20y%20%5C%20%5Crightarrow%20%5C%20%5By%20%2F%20x_2%5D%20x_2%20%5C%20%3D%20%5C%20y" alt="(\lambda x_2. x_2) \ y \ \rightarrow \ [y / x_2] x_2 \ = \ y" title="(\lambda x_2. x_2) \ y \ \rightarrow \ [y / x_2] x_2 \ = \ y" /></p>
<p>On the other hand, the lambda term <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20x%20%5C%20y%29%20%5C%20%28%28%5Clambda%20x.%20x%29%20%5C%20%28%5Clambda%20x.%20x%29%29" alt="(\lambda x. x \ y) \ ((\lambda x. x) \ (\lambda x. x))" title="(\lambda x. x \ y) \ ((\lambda x. x) \ (\lambda x. x))" /> evaluates to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" />. Briefly, the evaluation steps are</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20x%20%5C%20y%29%20%5C%20%28%28%5Clambda%20x.%20x%29%20%5C%20%28%5Clambda%20x.%20x%29%29" alt="(\lambda x. x \ y) \ ((\lambda x. x) \ (\lambda x. x))" title="(\lambda x. x \ y) \ ((\lambda x. x) \ (\lambda x. x))" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=-_%7BRenaming%7D%20%5C%20%28%5Clambda%20x_1.%20x_1%20%5C%20y%29%20%5C%20%28%28%5Clambda%20x_2.%20x_2%29%20%5C%20%28%5Clambda%20x_3.%20x_3%29%29" alt="-_{Renaming} \ (\lambda x_1. x_1 \ y) \ ((\lambda x_2. x_2) \ (\lambda x_3. x_3))" title="-_{Renaming} \ (\lambda x_1. x_1 \ y) \ ((\lambda x_2. x_2) \ (\lambda x_3. x_3))" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%20%28%5Clambda%20x_1.%20x_1%20%5C%20y%29%20%5C%20%28%5Clambda%20x_3.%20x_3%29" alt="\rightarrow \ (\lambda x_1. x_1 \ y) \ (\lambda x_3. x_3)" title="\rightarrow \ (\lambda x_1. x_1 \ y) \ (\lambda x_3. x_3)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%20%28%5Clambda%20x_3.%20x_3%29%20%5C%20y" alt="\rightarrow \ (\lambda x_3. x_3) \ y" title="\rightarrow \ (\lambda x_3. x_3) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%20y" alt="\rightarrow \ y" title="\rightarrow \ y" /></p>
<h3 id="expressivenesschurch-encoding">Expressiveness/Church Encoding</h3>
<p>How expressive is the lambda calculus? As expressive as a Turing machine?</p>
<p>Yes! But how? The lambda calculus looks rather simple.</p>
<p>Indeed, but as we will show next, we can encode data types (booleans, ...), conditional expressions, recursion.</p>
<p>The idea of the Church encoding (named after Alonzo Church):</p>
<ul>
<li>Encode behavior not structure</li>
</ul>
<h4 id="boolean-operations">Boolean operations</h4>
<p>The idea:</p>
<ul>
<li><p>not x = if x then false else true</p></li>
<li><p>x or y = if x then true else y</p></li>
<li><p>x and y = if x then y else false</p></li>
</ul>
<p>The actual encoding:</p>
<ul>
<li><p>true = <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.%20%5Clambda%20y.x" alt="\lambda x. \lambda y.x" title="\lambda x. \lambda y.x" /></p></li>
<li><p>false = <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20x.%20%5Clambda%20y.%20y" alt="\lambda x. \lambda y. y" title="\lambda x. \lambda y. y" /></p></li>
<li><p>if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_1" alt="e_1" title="e_1" /> then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_2" alt="e_2" title="e_2" /> else <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_3" alt="e_3" title="e_3" /> = <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_1%20%5C%20e_2%20%5C%20e_3" alt="e_1 \ e_2 \ e_3" title="e_1 \ e_2 \ e_3" /></p></li>
</ul>
<p>which written in 'lambda notation' is</p>
<p>ite = <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clambda%20e_1.%20%5Clambda%20e_2.%20%5Clambda%20e_3.%20e_1%20%5C%20e_2%20%5C%20e_3" alt="\lambda e_1. \lambda e_2. \lambda e_3. e_1 \ e_2 \ e_3" title="\lambda e_1. \lambda e_2. \lambda e_3. e_1 \ e_2 \ e_3" /></p>
<p>Example: if true then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_2" alt="e_2" title="e_2" /> else <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_3" alt="e_3" title="e_3" /> equals <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20%5Clambda%20y.%20x%29%20%5C%20e_2%20%5C%20e_3" alt="(\lambda x. \lambda y. x) \ e_2 \ e_3" title="(\lambda x. \lambda y. x) \ e_2 \ e_3" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20%5Clambda%20y.%20x%29%20%5C%20e_2%20%5C%20e_3" alt="(\lambda x. \lambda y. x) \ e_2 \ e_3" title="(\lambda x. \lambda y. x) \ e_2 \ e_3" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20e_2" alt="\rightarrow e_2" title="\rightarrow e_2" /></p>
<p>In detail:</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x.%20%5Clambda%20y.%20x%29%20%5C%20e_2%20%5C%20e_3" alt="(\lambda x. \lambda y. x) \ e_2 \ e_3" title="(\lambda x. \lambda y. x) \ e_2 \ e_3" /></p>
<p>= <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%28%5Clambda%20x.%20%5Clambda%20y.%20x%29%20%5C%20e_2%29%20%5C%20e_3" alt="((\lambda x. \lambda y. x) \ e_2) \ e_3" title="((\lambda x. \lambda y. x) \ e_2) \ e_3" /></p>
<p>by adding parentheses (recall that function application is left associative)</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%28%5Clambda%20y.e_2%29%20%5C%20e_3" alt="\rightarrow (\lambda y.e_2) \ e_3" title="\rightarrow (\lambda y.e_2) \ e_3" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20e_2" alt="\rightarrow e_2" title="\rightarrow e_2" /></p>
<h5 id="boolean-operations-example">Boolean operations example</h5>
<p>We evaluate <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=ite%20%5C%20true%20%5C%20x%20%5C%20y" alt="ite \ true \ x \ y" title="ite \ true \ x \ y" />. The expect result is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />. Let's see!</p>
<ol style="list-style-type: decimal">
<li>Replace short-hands by actual definitions.</li>
</ol>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=ite%20%5C%20true%20%5C%20x%20%5C%20y%20%3D%20%28%5Clambda%20x.%20%5Clambda%20y.%20%5Clambda%20z.%20x%20%5C%20y%20%5C%20z%29%20%5C%20%28%5Clambda%20x.%20%5Clambda%20y.%20x%29%20%5C%20x%20%5C%20y" alt="ite \ true \ x \ y = (\lambda x. \lambda y. \lambda z. x \ y \ z) \ (\lambda x. \lambda y. x) \ x \ y" title="ite \ true \ x \ y = (\lambda x. \lambda y. \lambda z. x \ y \ z) \ (\lambda x. \lambda y. x) \ x \ y" /></p>
<ol start="2" style="list-style-type: decimal">
<li>Rename variables such that all bound variables are distinct</li>
</ol>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Clambda%20x_1.%20%5Clambda%20y_1.%20%5Clambda%20z_1.%20x_1%20%5C%20y_1%20%5C%20z_1%29%20%5C%20%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%20%5C%20x%20%5C%20y" alt="(\lambda x_1. \lambda y_1. \lambda z_1. x_1 \ y_1 \ z_1) \ (\lambda x_2. \lambda y_2. x_2) \ x \ y" title="(\lambda x_1. \lambda y_1. \lambda z_1. x_1 \ y_1 \ z_1) \ (\lambda x_2. \lambda y_2. x_2) \ x \ y" /></p>
<ol start="3" style="list-style-type: decimal">
<li>Introduce parantheses</li>
</ol>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%28%28%5Clambda%20x_1.%20%5Clambda%20y_1.%20%5Clambda%20z_1.%20%28x_1%20%5C%20y_1%29%20%5C%20z_1%29%20%5C%20%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%29%20%5C%20x%29%20%5C%20y" alt="(((\lambda x_1. \lambda y_1. \lambda z_1. (x_1 \ y_1) \ z_1) \ (\lambda x_2. \lambda y_2. x_2)) \ x) \ y" title="(((\lambda x_1. \lambda y_1. \lambda z_1. (x_1 \ y_1) \ z_1) \ (\lambda x_2. \lambda y_2. x_2)) \ x) \ y" /></p>
<ol start="4" style="list-style-type: decimal">
<li>Carry out evaluation steps</li>
</ol>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%28%28%5Clambda%20x_1.%20%5Clambda%20y_1.%20%5Clambda%20z_1.%20%28x_1%20%5C%20y_1%29%20%5C%20z_1%29%20%5C%20%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%29%20%5C%20x%29%20%5C%20y" alt="(((\lambda x_1. \lambda y_1. \lambda z_1. (x_1 \ y_1) \ z_1) \ (\lambda x_2. \lambda y_2. x_2)) \ x) \ y" title="(((\lambda x_1. \lambda y_1. \lambda z_1. (x_1 \ y_1) \ z_1) \ (\lambda x_2. \lambda y_2. x_2)) \ x) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%28%28%5B%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%20%2F%20x_1%5D%20%28%5Clambda%20y_1.%20%5Clambda%20z_1.%20%28x_1%20%5C%20y_1%29%20%5C%20z_1%29%29%20%5C%20x%29%20%5C%20y" alt="\rightarrow (([(\lambda x_2. \lambda y_2. x_2) / x_1] (\lambda y_1. \lambda z_1. (x_1 \ y_1) \ z_1)) \ x) \ y" title="\rightarrow (([(\lambda x_2. \lambda y_2. x_2) / x_1] (\lambda y_1. \lambda z_1. (x_1 \ y_1) \ z_1)) \ x) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D%20%28%28%28%5Clambda%20y_1.%20%5Clambda%20z_1.%20%28%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%20%5C%20y_1%29%20%5C%20z_1%29%29%20%5C%20x%29%20%5C%20y" alt="= (((\lambda y_1. \lambda z_1. ((\lambda x_2. \lambda y_2. x_2) \ y_1) \ z_1)) \ x) \ y" title="= (((\lambda y_1. \lambda z_1. ((\lambda x_2. \lambda y_2. x_2) \ y_1) \ z_1)) \ x) \ y" /></p>
<p>Several redexes. We choose the outermost redex</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%28%5Bx%20%2F%20y_1%5D%20%28%5Clambda%20z_1.%20%28%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%20%5C%20y_1%29%20%5C%20z_1%29%29%20%5C%20y" alt="\rightarrow ([x / y_1] (\lambda z_1. ((\lambda x_2. \lambda y_2. x_2) \ y_1) \ z_1)) \ y" title="\rightarrow ([x / y_1] (\lambda z_1. ((\lambda x_2. \lambda y_2. x_2) \ y_1) \ z_1)) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D%20%28%5Clambda%20z_1.%20%28%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%20%5C%20x%29%20%5C%20z_1%29%20%5C%20y" alt="= (\lambda z_1. ((\lambda x_2. \lambda y_2. x_2) \ x) \ z_1) \ y" title="= (\lambda z_1. ((\lambda x_2. \lambda y_2. x_2) \ x) \ z_1) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5By%20%2F%20z_1%5D%20%28%28%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%20%5C%20x%29%20%5C%20z_1%29" alt="\rightarrow [y / z_1] (((\lambda x_2. \lambda y_2. x_2) \ x) \ z_1)" title="\rightarrow [y / z_1] (((\lambda x_2. \lambda y_2. x_2) \ x) \ z_1)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D%20%28%28%5Clambda%20x_2.%20%5Clambda%20y_2.%20x_2%29%20%5C%20x%29%20%5C%20y" alt="= ((\lambda x_2. \lambda y_2. x_2) \ x) \ y" title="= ((\lambda x_2. \lambda y_2. x_2) \ x) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%28%5Bx%20%2F%20x_2%5D%20%28%5Clambda%20y_2.%20x_2%29%29%20%5C%20y" alt="\rightarrow ([x / x_2] (\lambda y_2. x_2)) \ y" title="\rightarrow ([x / x_2] (\lambda y_2. x_2)) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D%20%28%5Clambda%20y_2.%20x%29%20%5C%20y" alt="= (\lambda y_2. x) \ y" title="= (\lambda y_2. x) \ y" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5By%20%2F%20y_2%5D%20x" alt="\rightarrow [y / y_2] x" title="\rightarrow [y / y_2] x" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D%20x" alt="= x" title="= x" /></p>
<h4 id="recursion">Recursion</h4>
<p>What about recursion?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">     factorial n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span>
                   <span class="kw">else</span> n <span class="fu">*</span> (factorial (n<span class="fu">-</span><span class="dv">1</span>))</code></pre></div>
<p>Idea:</p>
<ul>
<li>Fixpointcombinator
<ul>
<li><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Y%20%3D%20%5Clambda%20F.%28%5Clambda%20y.F%20%5C%20%28y%20%5C%20y%29%29%20%5C%20%28%5Clambda%20x.F%20%5C%20%28x%20%5C%20x%29%29" alt="Y = \lambda F.(\lambda y.F \ (y \ y)) \ (\lambda x.F \ (x \ x))" title="Y = \lambda F.(\lambda y.F \ (y \ y)) \ (\lambda x.F \ (x \ x))" /></li>
<li>We find that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Y%20%5C%20F%20%3D%20F%20%5C%20%28Y%20F%29" alt="Y \ F = F \ (Y F)" title="Y \ F = F \ (Y F)" /></li>
</ul></li>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Fac%20%3D%20%5Clambda%20fac.%20%5Clambda%20n.%20if%20%5C%20%20%28n%3D%3D0%29%20%5C%20%5C%20then%20%5C%201%20%5C%20else%20%5C%20n%2A%28fac%20%5C%20%28n-1%29%29" alt="Fac = \lambda fac. \lambda n. if \  (n==0) \ \ then \ 1 \ else \ n*(fac \ (n-1))" title="Fac = \lambda fac. \lambda n. if \  (n==0) \ \ then \ 1 \ else \ n*(fac \ (n-1))" /></p></li>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=factorial%20%3D%20Y%20%5C%20Fac" alt="factorial = Y \ Fac" title="factorial = Y \ Fac" /></p></li>
</ul>
<p>This works!</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=factorial%20%5C%201" alt="factorial \ 1" title="factorial \ 1" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow_%7Bdef%7D%20%5C%20%20%28Y%20%5C%20Fac%29%20%5C%201" alt="\rightarrow_{def} \  (Y \ Fac) \ 1" title="\rightarrow_{def} \  (Y \ Fac) \ 1" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow_%7Bfix%7D%20%5C%20%20%28Fac%20%5C%20%28Y%20%5C%20Fac%29%29%20%5C%201" alt="\rightarrow_{fix} \  (Fac \ (Y \ Fac)) \ 1" title="\rightarrow_{fix} \  (Fac \ (Y \ Fac)) \ 1" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow_%7Bdef%7D%20%5C%20%20%20%28%28%5Clambda%20fac.%20%5Clambda%20n.%20if%20%5C%20%28n%20%3D%3D%200%29%20%5C%20then%20%5C%201%20%5C%20else%20%5C%20n%2A%28fac%20%5C%28n-1%29%29%29%20%20%5C%20%28Y%20%5CFac%29%29%20%5C%201" alt="\rightarrow_{def} \   ((\lambda fac. \lambda n. if \ (n == 0) \ then \ 1 \ else \ n*(fac \(n-1)))  \ (Y \Fac)) \ 1" title="\rightarrow_{def} \   ((\lambda fac. \lambda n. if \ (n == 0) \ then \ 1 \ else \ n*(fac \(n-1)))  \ (Y \Fac)) \ 1" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%20%20%20%28%5Clambda%20n.%20if%20%5C%20%28n%3D%3D0%29%20%5C%20then%20%5C%201%20%5C%20else%20%5C%20n%2A%28%28Y%20%5C%20Fac%29%20%5C%20%28n-1%29%29%29%20%5C%201" alt="\rightarrow \   (\lambda n. if \ (n==0) \ then \ 1 \ else \ n*((Y \ Fac) \ (n-1))) \ 1" title="\rightarrow \   (\lambda n. if \ (n==0) \ then \ 1 \ else \ n*((Y \ Fac) \ (n-1))) \ 1" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%0A%201%20%2A%20%28%28Y%20%5C%20Fac%29%20%5C%200%29" alt="\rightarrow \
 1 * ((Y \ Fac) \ 0)" title="\rightarrow \
 1 * ((Y \ Fac) \ 0)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow_%7Bfix%7D%20%5C%20%201%20%2A%20%28%28Fac%20%5C%20%28Y%20%5C%20Fac%29%29%20%5C%200%29" alt="\rightarrow_{fix} \  1 * ((Fac \ (Y \ Fac)) \ 0)" title="\rightarrow_{fix} \  1 * ((Fac \ (Y \ Fac)) \ 0)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%201%20%2A%20%28%28%5Clambda%20n.%20if%20%5C%20%28n%20%3D%3D%200%29%20%5C%20then%20%5C%201%20%5C%20else%20%5C%20n%2A%28%28Y%20%5C%20Fac%29%20%5C%20%28n-1%29%29%29%20%5C%200%29" alt="\rightarrow \ 1 * ((\lambda n. if \ (n == 0) \ then \ 1 \ else \ n*((Y \ Fac) \ (n-1))) \ 0)" title="\rightarrow \ 1 * ((\lambda n. if \ (n == 0) \ then \ 1 \ else \ n*((Y \ Fac) \ (n-1))) \ 0)" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%201%20%2A%201" alt="\rightarrow \ 1 * 1" title="\rightarrow \ 1 * 1" /></p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crightarrow%20%5C%201" alt="\rightarrow \ 1" title="\rightarrow \ 1" /></p>
<p>More encodings (pairs, natural numbers) are possible. See <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a>.</p>
</div>
</body>
</html>
